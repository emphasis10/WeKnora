# 서버 설정
server:
  port: 8080
  host: "0.0.0.0"

# 대화 서비스 설정
conversation:
  max_rounds: 5
  keyword_threshold: 0.3
  embedding_top_k: 10
  vector_threshold: 0.5
  rerank_threshold: 0.5
  rerank_top_k: 5
  fallback_strategy: "model"
  fallback_response: "죄송합니다. 해당 질문에 답변할 수 없습니다."
  fallback_prompt: |
    당신은 전문적이고 친절한 AI 어시스턴트입니다. 당신의 지식에 따라 사용자의 질문에 직접 답변해 주세요.

    ## 답변 요구사항
    - 사용자의 질문에 직접 답변할 것
    - 간결하고 명확하며 알찬 내용을 담을 것
    - 실시간 데이터나 개인 정보가 포함된 경우, 획득할 수 없음을 솔직하게 설명할 것
    - 예의 바르고 전문적인 어조를 사용할 것

    ## 사용자의 질문:
    {{.Query}}
  enable_rewrite: true
  enable_query_expansion: true
  enable_rerank: true
  rewrite_prompt_system: |
    당신은 지칭 해소(Coreference Resolution)와 생략 보충에 특화된 지능형 어시스턴트입니다. 당신의 임무는 대화 문맥을 바탕으로 사용자 질문 속의 대명사를 명확한 주어로 물리치고, 생략된 핵심 정보를 보충하는 것입니다.

    ## 개작 목표
    대화 이력을 바탕으로 현재 사용자 질문을 다음과 같이 개작해 주세요:
    - 지칭 해소 수행: "그것", "이것", "저것", "그", "그녀", "그들" 등의 대명사를 명확한 주어로 변경
    - 생략된 핵심 정보 보충: 질문의 의미가 완전해지도록 보완
    - 질문의 원의미와 표현 방식 유지
    - 개작 후에도 반드시 질문 형태여야 함
    - 개작된 질문은 30자 이내로 제한
    - 개작된 질문만 출력하고, 설명이나 답변은 하지 말 것 (이후 다른 어시스턴트가 답변할 예정임)

    ## Few-shot 예시

    예시 1:
    대화 이력:
    사용자: 카카오페이에는 어떤 기능이 있나요?
    어시스턴트: 카카오페이의 주요 기능으로는 송금, 결제, 멤버십, 청구서 등 다양한 금융 서비스가 있습니다.

    사용자 질문: 그것의 보안성
    개작 후: 카카오페이의 보안성

    예시 2:
    대화 이력:
    사용자: 아이폰 배터리가 빨리 닳는데 어떻게 하나요?
    어시스턴트: 화면 밝기 조절, 백그라운드 앱 종료, 정기적인 시스템 업데이트를 통해 배터리 수명을 연장할 수 있습니다.

    사용자 질문: 이렇게 하면 사용 경험에 지장이 없나요?
    개작 후: 화면 밝기 조절과 백그라운드 앱 종료가 사용 경험에 지장을 주나요

    예시 3:
    대화 이력:
    사용자: 김치찌개 만드는 법 알려줘.
    어시스턴트: 김치찌개는 먼저 김치와 고기를 볶은 후 육수를 붓고 끓이면 됩니다.

    사용자 질문: 얼마나 끓여야 해?
    개작 후: 김치찌개를 얼마나 끓여야 하나요

    예시 4:
    대화 이력:
    사용자: 서울에서 부산까지 KTX 요금이 얼마인가요?
    어시스턴트: 열차 종류와 좌석 등급에 따라 다르며, 일반실 기준 약 59,800원입니다.

    사용자 질문: 시간은요?
    개작 후: 서울에서 부산까지 KTX 소요 시간

    예시 5:
    대화 이력:
    사용자: 어떻게 계정을 만드나요?
    어시스턴트: 앱을 다운로드하고 휴대폰 번호를 입력한 뒤 인증번호를 받고 닉네임과 비밀번호를 설정하면 됩니다.

    사용자 질문: 외국 번호도 되나요?
    개작 후: 외국 휴대폰 번호로도 계정 가입이 가능한가요
  rewrite_prompt_user: |
    ## 대화 문맥 배경
    {{range .Conversation}}
    ------BEGIN------
    사용자 질문: {{.Query}}
    어시스턴트 답변: {{.Answer}}
    ------END------
    {{end}}

    ## 개작할 사용자 질문
    {{.Query}}

    ## 개작된 질문
  keywords_extraction_prompt: |
    # 역할
    당신은 전문적인 키워드 추출 어시스턴트입니다. 당신의 임무는 사용자의 질문에서 가장 중요한 키워드/구를 추출하는 것입니다.

    # 요구사항
    - 사용자 질문을 요약하고 가장 중요한 키워드/구를 최대 5개까지 제시할 것
    - 키워드/구 사이는 쉼표(,)로 구분할 것
    - 키워드/구는 반드시 사용자 질문에 포함된 내용이어야 하며, 지어내지 말 것
    - 설명은 생략하고 키워드만 직접 출력할 것. 접두사, 설명, 문장 부호를 넣지 말고 질문에 답변하려고 하지 말 것

    # 출력 형식
    keyword1, keyword2, keyword3, keyword4, keyword5

    # 예시

    ## 예시 1
    USER: 영어 회화 실력을 높이는 방법은?
    ###############
    Output: 영어 회화, 회화 실력, 영어 회화 향상, 영어 회화 연습, 회화 실력 향상

    ## 예시 2
    USER: 최근 서울에서 가볼 만한 전시회가 있어?
    ###############
    Output: 서울 전시회, 전시회 추천, 서울 가볼 만한 곳, 전시 활동, 서울 전시

    ## 예시 3
    USER: 아이폰 배터리 효율 떨어질 때 해결책은?
    ###############
    Output: 아이폰, 배터리 효율, 배터리 최적화, 배터리 수명, 배터리 관리

    ## 예시 4
    USER: 파이썬 로고는 어떻게 생겼어?
    ###############
    Output: 파이썬 로고, Python Logo

    ## 예시 5
    USER: 아이폰으로 와이파이 연결하는 법
    ###############
    Output: 아이폰, 와이파이 연결, 아이폰 와이파이 설정

    # 실제 데이터
    USER: {{.Query}}

  keywords_extraction_prompt_user: |
    Output:

  generate_summary_prompt: |
    당신은 정확한 문서 요약 전문가입니다. 당신의 임무는 사용자가 제공한 글이나 발췌문의 핵심 내용을 추출하고 요약하는 것입니다.

    ## 핵심 요구사항
    - 요약 결과의 길이는 공백 포함 50-150자 정도로, 내용의 복잡도에 따라 유연하게 조절할 것
    - 제공된 글의 내용에만 기반하여 요약을 생성하고, 본문에 없는 정보는 추가하지 말 것
    - 문서의 핵심 포인트와 주요 결론이 반드시 포함되도록 할 것
    - 내용이 복잡하거나 전문적이더라도 핵심 요점을 정확히 추출할 것
    - 도입부, 접두사, 설명 없이 요약 결과만 직접 출력할 것

    ## 형식 및 어조
    - 객관적이고 중립적인 3인칭 서술 어조를 사용할 것
    - 명확하고 간결한 한국어로 표현할 것
    - 문장 간의 논리적 연결성을 유지할 것
    - 동일한 표현이나 문장 구조를 반복하지 말 것

    ## 주의사항
    - "요약할 수 없음", "내용 부족" 등의 거부 응답을 절대 하지 말 것
    - 예시에 나온 내용을 베끼지 말고, 오직 새로 제공된 글에만 기반하여 요약할 것
    - 글의 길이나 복잡도에 상관없이 최선을 다해 요약할 것
    
    ## 사용자로부터 제공된 문서 관련 정보:

  generate_session_title_prompt: |
    사용자의 질문을 바탕으로 짧은 대화방 제목을 생성해 주세요.

    요구사항:
    - 5-10자 이내
    - 핵심 주제 추출
    - 설명 없이 제목만 출력

    사용자 질문:
  summary:
    repeat_penalty: 1.0
    temperature: 0.3
    max_completion_tokens: 2048
    no_match_prefix: |-
      <think>
      </think>
      NO_MATCH
    prompt: |
      당신은 WeKnora라는 이름의 전문적인 지능형 정보 검색 어시스턴트입니다. 당신은 마치 숙련된 비서처럼 검색된 정보에 기반하여 사용자의 질문에 답변해야 하며, 선험적 지식을 사용해서는 안 됩니다.
      사용자가 질문을 하면, 어시스턴트는 특정 정보를 바탕으로 답변합니다. 먼저 마음속으로 추론 과정을 거친 뒤 사용자에게 답을 제공합니다.
    context_template: |
      ## 답변 규칙
      - 오직 검색된 정보의 사실에 근거하여 답변하며, 선험적 지식을 사용하지 마십시오. 객관성과 정확성을 유지하십시오.
      - 복잡한 질문과 답변은 Markdown 구조를 사용하여 보여주되, 전체 요약 부분은 나눌 필요 없습니다.
      - 간단한 답변인 경우 최종 답변을 너무 잘게 쪼개지 마십시오.
      - 결과에 사용되는 이미지 주소는 반드시 검색된 정보에서 가져와야 하며, 지어내지 마십시오.
      - 텍스트와 이미지가 검색된 정보에 포함되어 있는지 확인하고, 포함되지 않은 내용을 확장했다면 최종 답변이 나올 때까지 수정하십시오.
      - 답변이 불가능한 경우 사용자에게 정중히 알리고 합리적인 제안을 하십시오.

      ## 출력 제한
      - 최종 결과를 Markdown 이미지/텍스트 형식으로 출력하십시오.
      - 내용은 간결하면서도 포괄적이어야 하며, 논리적이고 명확해야 합니다. 중복을 피하십시오.

      ## 현재 시간:
      {{.CurrentTime}} {{.CurrentWeek}}

      ## 검색된 정보는 다음과 같습니다:
      ------BEGIN------
      {{range .Contexts}}
      {{.}}
      {{end}}
      ------END------

      ## 사용자의 현재 질문:
      {{.Query}}
  extract_entities_prompt: |
    ## 임무
    사용자가 제공한 텍스트에서 다음 유형에 해당하는 모든 개체를 추출하십시오:
    EntityTypes: [Person, Organization, Location, Product, Event, Date, Work, Concept, Resource, Category, Operation]

    ## 요구사항
    1. 추출 결과는 반드시 JSON 배열 형식으로 출력되어야 합니다.
    2. 각 개체는 title과 type 필드를 포함해야 하며, description 필드는 선택 사항이나 제공하는 것을 권장합니다.
    3. type 필드의 값은 반드시 EntityTypes 목록에서 엄격하게 선택해야 하며 새로운 유형을 만들지 마십시오.
    4. 개체 유형을 확신할 수 없는 경우 억지로 분류하지 말고 해당 개체를 추출하지 마십시오.
    5. 설명이나 추가 내용 없이 JSON 배열만 출력하십시오.
    6. 모든 필드 값에는 HTML 태그나 기타 코드가 포함되어서는 안 됩니다.
    7. 개체의 의미가 모호한 경우 description에 구체적인 지칭 대상을 설명하십시오.
    8. 개체를 찾지 못한 경우 빈 배열 []을 반환하십시오.

    ## 개체 추출 규칙
    - Person: 역사적 인물, 현대 인물, 문학적 캐릭터 등을 포함한 실존 또는 가상 인물
    - Organization: 회사, 정부 기관, 팀, 학교 등 조직체
    - Location: 지리적 위치, 랜드마크, 국가, 도시 등
    - Product: 상품, 서비스, 브랜드 등 상업적 제품
    - Event: 사건, 회의, 축제, 역사적 사건 등
    - Date: 날짜, 기간, 연대 등 시간 관련 정보
    - Work: 서적, 영화, 음악, 예술 작품 등 창작물
    - Concept: 추상적 개념, 사상, 이론 등
    - Resource: 천연자원, 정보 자원, 도구 등
    - Category: 분류, 범주, 영역 등
    - Operation: 조작, 동작, 방법, 과정 등

    ## 추출 단계
    1. 텍스트를 주의 깊게 읽고 가능한 개체를 식별합니다.
    2. 식별된 각 개체에 대해 가장 적합한 유형을 EntityTypes에서 선택합니다.
    3. 다음 필드를 포함하는 JSON 객체를 생성합니다:
       - title: 따옴표 등 수식어가 없는 개체의 표준 명칭
       - type: EntityTypes에서 선택한 유형
       - description: 텍스트 내용에 기반한 간결한 한국어 설명
    4. 각 개체의 모든 필드가 정확하고 형식이 적절한지 검증합니다.
    5. 모든 개체 객체를 하나의 JSON 배열로 합칩니다.
    6. 최종 JSON이 유효하고 요구사항을 충족하는지 확인합니다.

    ## 예시
    [입력]
    텍스트: 《홍길동전》은 조선 시대의 고전 소설로, 작가는 허균으로 알려져 있습니다. 이 작품은 사회의 부조리에 맞서는 영웅 홍길동의 이야기를 다루고 있으며, 한국 문학사에서 중요한 위치를 차지합니다.

    [출력]
    [
      {
        "title": "홍길동전",
        "type": "Work",
        "description": "조선 시대의 고전 소설이자 홍길동의 영웅담을 다룬 작품"
      },
      {
        "title": "허균",
        "type": "Person",
        "description": "홍길동전의 저자로 알려진 인물"
      },
      {
        "title": "홍길동",
        "type": "Person",
        "description": "소설 속의 주인공이자 사회 부조리에 맞서는 영웅"
      },
      {
        "title": "조선 시대",
        "type": "Date",
        "description": "홍길동전의 배경이 되는 역사적 시대"
      },
      {
        "title": "한국 문학사",
        "type": "Category",
        "description": "홍길동전이 중요한 위치를 차지하고 있는 학문 영역"
      }
    ]

  extract_relationships_prompt: |
    ## 임무
    사용자가 제공한 개체 배열에서 개체 간의 명확한 관계를 추출하여 구조화된 관계망을 형성하십시오.

    ## 요구사항
    1. 관계 추출은 반드시 제공된 텍스트 내용에 기반해야 하며, 존재하지 않는 관계를 추측하지 마십시오.
    2. 결과는 반드시 JSON 배열 형식으로 출력되어야 합니다.
    3. 각 관계 객체는 source, target, description, strength 필드를 포함해야 합니다.
    4. 추가 설명 없이 JSON 배열만 출력하십시오.
    5. 관계를 찾지 못한 경우 빈 배열 []을 반환하십시오.

    ## 관계 추출 규칙
    - 텍스트에 명확하게 나타난 관계만 추출합니다.
    - 소스(source)와 타겟(target) 개체는 반드시 제공된 개체 목록에 존재해야 합니다.
    - 관계 설명(description)은 두 개체 간의 구체적인 관계를 간결하게 설명합니다.
    - 관계 강도(strength)는 다음 기준에 따라 결정합니다:
      * 10점: 직접적인 창작/종속 관계 (예: 저자와 작품, 발명가와 발명품, 모회사와 자회사)
      * 9점: 동일 개체의 다른 표현 (예: 별칭, 이전 이름)
      * 8점: 밀접하게 관련되어 서로 영향을 주는 관계 (예: 긴밀한 파트너, 가족 구성원)
      * 7점: 명확하지만 직접적이지는 않은 관계 (예: 작품 속 캐릭터, 조직 구성원)
      * 6점: 간접적이지만 명확한 접점이 있는 관계 (예: 동료 관계, 유사 제품)
      * 5점: 연관성은 있으나 느슨한 관계 (예: 같은 분야의 다른 개념)

    ## 추출 단계
    1. 텍스트를 분석하여 어떤 개체 사이에 명확한 관계가 있는지 확인합니다.
    2. 텍스트에 언급된 관계만 고려하고 추측하지 마십시오.
    3. 각 관계에 대해 다음을 결정합니다:
       - source: 소스 개체의 제목 (목록에 있는 것)
       - target: 타겟 개체의 제목 (목록에 있는 것)
       - description: 명확하고 정확한 한국어 관계 설명
       - strength: 위 기준에 따른 정수값 (5-10 사이)
    4. 관계의 양방향성을 확인합니다:
       - 양방향 관계인 경우 반대 방향 관계 생성 여부를 고려합니다.
       - 단방향 관계인 경우 단방향만 유지합니다.
    5. 모든 관계의 일관성과 타당성을 검증합니다.
    6. 모든 유효한 관계를 JSON 배열로 구성합니다.

  generate_questions_prompt: |
    당신은 전문적인 질문 생성 어시스턴트입니다. 당신의 임무는 주어진 [주요 내용]을 바탕으로 사용자가 물어볼 법한 관련 질문을 생성하는 것입니다.

    {{.Context}}
    ## 주요 내용 (이 내용을 바탕으로 질문을 생성하세요)
    문서 이름: {{.DocName}}
    문서 내용:
    {{.Content}}

    ## 핵심 요구사항
    - 생성된 질문은 반드시 [주요 내용]과 직접적으로 연관되어야 합니다.
    - 질문 내에서 대명사(예: "그것", "이것", "이 문서", "본문", "이 글" 등) 사용을 금지하며, 반드시 구체적인 명칭으로 대체하십시오.
    - 질문은 문맥 없이도 이해될 수 있도록 완전하고 독립적이어야 합니다.
    - 실제 사용자가 자연스럽게 물어볼 만한 질문이어야 합니다.
    - 내용의 다양한 측면을 포괄하도록 질문을 다양화하십시오.
    - 각 질문은 간결하고 명확해야 하며, 30자 이내로 작성하십시오.
    - 생성할 질문의 개수는 {{.QuestionCount}}개입니다.

    ## 질문 유형 제안
    - 정의형: ...은 무엇인가요? ...의 정의는?
    - 원인형: 왜 ...인가요? ...의 원인은 무엇인가요?
    - 방법형: 어떻게 ...하나요? 방법은 무엇인가요?
    - 비교형: ...와 ...의 차이점은 무엇인가요?
    - 응용형: ...은 어떤 상황에서 사용되나요?

    ## 출력 형식
    번호나 다른 접두사 없이 한 줄에 하나씩 질문 목록만 출력하십시오.

# 지식베이스 설정
knowledge_base:
  chunk_size: 512
  chunk_overlap: 50
  split_markers: ["\n\n", "\n", "."]
  image_processing:
    enable_multimodal: true

extract:
  extract_graph:
    description: |
      주어진 텍스트를 바탕으로 다음 단계에 따라 정보 추출 작업을 완료하여 논리적이고 정확한 정보를 확보하십시오:

      ## 1. 개체 추출 및 속성 보충
      1. **핵심 개체 추출**: 텍스트를 정독하고 논리적 순서에 따라 작업과 관련된 모든 핵심 개체를 추출합니다.
      2. **상세 속성 보충**: 각 개체에 대해 텍스트에 언급된 상세 속성을 누락 없이 보충합니다.

      ## 2. 관계 추출 및 검증
      1. **관계 유형 정의**: 지정된 관계 목록에서만 유형을 선택합니다. 한정된 관계 유형: %s.
      2. **유효 관계 추출**: 추출된 개체와 속성을 바탕으로 텍스트에 실제로 존재하는 관계를 식별합니다.
      3. **관계 주체 명시**: 추출된 각 관계에 대해 두 관련 주체를 명확히 표시합니다.
      4. **관련 속성 보충**: 관계와 직접 관련된 추가 정보가 있다면 이를 관계 속성으로 보충합니다.
    tags:
      - "저자"
      - "별칭"
    examples:
      - text: |
          《홍길동전》은 허균이 지은 것으로 알려진 조선 시대의 영웅 소설입니다. 주인공 홍길동은 서자라는 차별을 극복하고 활빈당을 조직하여 부조리한 사회에 맞섭니다.
        node:
          - name: "홍길동전"
            attributes:
              - "조선 시대 영웅 소설"
              - "허균이 저자로 알려짐"
          - name: "허균"
            attributes:
              - "조선 시대 문신 및 작가"
              - "홍길동전의 저자"
          - name: "홍길동"
            attributes:
              - "소설 속 주인공"
              - "활빈당 조직"
        relation:
          - node1: "홍길동전"
            node2: "허균"
            type: "저자"
          - node1: "홍길동"
            node2: "홍길동전"
            type: "주인공"
  extract_entity:
    description: |
      사용자의 질문을 바탕으로 다음 단계에 따라 핵심 정보 추출 작업을 처리하십시오:
      1. 논리적 관계 정리: 먼저 본문 내용을 분석하여 핵심 논리 관계를 파악하고 해당 유형을 표시합니다.
      2. 핵심 개체 추출: 논리 관계를 중심으로 본문의 핵심 정보를 정확히 추출하여 개체로 분류합니다.
      3. 개체 우선순위 정렬: 본문 주제와의 연관성에 따라 우선순위를 정하여 가장 중요한 개체부터 제시합니다.
    examples:
      - text: "《홍길동전》은 허균이 지은 조선 시대의 대표적인 고전 소설입니다."
        node:
          - name: "홍길동전"
          - name: "허균"
          - name: "고전 소설"
  fabri_text:
    with_tag: |
      %s 등의 태그와 관련된 내용을 무작위로 생성하십시오. 글자 수는 [50-200]자 사이여야 하며, 해당 태그와 관련된 전문 용어나 전형적인 요소를 포함하여 관련성을 높이십시오.
    with_no_tag: |
      [50-200]자 사이의 텍스트를 자유롭게 무작위로 생성하십시오.

# 웹 검색 설정
web_search:
  # 사용 가능한 검색 엔진 목록
  providers:
    - id: "duckduckgo"
      name: "DuckDuckGo"
      free: true
      requires_api_key: false
      description: "DuckDuckGo API"

  # 기본 설정
  default:
    provider: "duckduckgo"
    max_results: 5
    include_date: true
    compression_method: "none"
    blacklist: []
  
  # 전체 타임아웃 설정
  timeout: 10

# 테넌트 설정
tenant:
  # 테넌트 간 액세스 기능 활성화 여부
  enable_cross_tenant_access: false
